<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Mok Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #video-input {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 160px; /* å°çª—å£é¢„è§ˆ */
            height: 120px;
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.5;
            z-index: 2;
            border: 1px solid #0ff;
        }
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0ff;
            z-index: 3;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: 24px;
            z-index: 10;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading" class="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ ¸å¿ƒ...</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <h2 id="status-text">ç­‰å¾…æ‰‹åŠ¿...</h2>
        <p>ğŸ– çƒä½“ | âœŒï¸ æ–‡å­— | âœŠ åœ†ç¯ | â˜ï¸ æ˜Ÿæ˜Ÿ | ğŸ‘ çˆ±å¿ƒ</p>
        <p>å½“å‰ç²’å­æ•°: 16,000 | ç‰©ç†å¼•æ“: æ¿€æ´»</p>
    </div>

<script>
/**
 * æ ¸å¿ƒé…ç½®
 */
const CONFIG = {
    particleCount: 16000,
    color: 0x00ffff, // é’è‰²
    particleSize: 0.15,
    damping: 0.94, // é˜»å°¼ï¼Œè¶Šå°åœå¾—è¶Šå¿«
    stiffness: 0.08, // å¼¹ç°§åŠ²åº¦ï¼Œè¶Šå¤§å½’ä½è¶Šå¿«
    explosionForce: 2.0, // åˆ‡æ¢æ—¶çš„çˆ†ç‚¸åŠ›åº¦
    windForce: 5.0, // æŒ¥æ‰‹é£æš´åŠ›åº¦
    depthScale: 20 // æ·±åº¦ç¼©æ”¾å€ç‡
};

// å…¨å±€å˜é‡
let scene, camera, renderer, particles, geometry;
let positions, velocities, accelerations, targets; // ç‰©ç†å±æ€§æ•°ç»„
let currentShape = 'sphere';
let handCentroid = new THREE.Vector3(0, 0, 0);
let handVelocity = new THREE.Vector2(0, 0);
let prevHandPos = new THREE.Vector2(0, 0);
let isHandPresent = false;
let palmRatio = 0; // æ‰‹æŒå å±å¹•æ¯”ä¾‹
let animationFrameId;

// å½¢çŠ¶ç¼“å­˜
const shapes = {
    sphere: [],
    text: [],
    ring: [],
    star: [],
    heart: []
};

/**
 * 1. åˆå§‹åŒ– Three.js ç¯å¢ƒ
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    // æ·»åŠ ä¸€ç‚¹ç¯å¢ƒé›¾ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    createParticleSystem();
    generateShapes();
    
    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', onWindowResize, false);
}

/**
 * 2. åˆ›å»ºç²’å­ç³»ç»Ÿ (BufferGeometry)
 */
function createParticleSystem() {
    geometry = new THREE.BufferGeometry();
    
    // åˆå§‹åŒ–æ•°ç»„
    positions = new Float32Array(CONFIG.particleCount * 3);
    velocities = new Float32Array(CONFIG.particleCount * 3); // é€Ÿåº¦
    accelerations = new Float32Array(CONFIG.particleCount * 3); // åŠ é€Ÿåº¦ (æœªä½¿ç”¨ï¼Œç›´æ¥å åŠ åŠ›åˆ°é€Ÿåº¦)
    targets = new Float32Array(CONFIG.particleCount * 3); // ç›®æ ‡ä½ç½®

    const colors = [];

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åˆå§‹éšæœºä½ç½®
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        velocities[i * 3] = 0;
        velocities[i * 3 + 1] = 0;
        velocities[i * 3 + 2] = 0;

        targets[i * 3] = 0;
        targets[i * 3 + 1] = 0;
        targets[i * 3 + 2] = 0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    // åˆ›å»ºå‘å…‰æè´¨
    // åŠ¨æ€ç”Ÿæˆä¸€ä¸ªåœ†å½¢è¾‰å…‰çº¹ç†
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(0,255,255,0.5)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    const texture = new THREE.CanvasTexture(canvas);

    const material = new THREE.PointsMaterial({
        color: CONFIG.color,
        size: CONFIG.particleSize,
        map: texture,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

/**
 * 3. ç”Ÿæˆå„ç§å½¢çŠ¶çš„ç›®æ ‡ç‚¹æ•°æ®
 */
function generateShapes() {
    const count = CONFIG.particleCount;

    // 1. Sphere
    const sphereData = [];
    const radius = 10;
    for (let i = 0; i < count; i++) {
        const phi = Math.acos(-1 + (2 * i) / count);
        const theta = Math.sqrt(count * Math.PI) * phi;
        sphereData.push(
            radius * Math.cos(theta) * Math.sin(phi),
            radius * Math.sin(theta) * Math.sin(phi),
            radius * Math.cos(phi)
        );
    }
    shapes.sphere = sphereData;

    // 2. Text "æˆ‘æ˜¯å¸…å“¥" via Canvas
    const textData = [];
    const txtCanvas = document.createElement('canvas');
    const txtCtx = txtCanvas.getContext('2d');
    txtCanvas.width = 400;
    txtCanvas.height = 200;
    txtCtx.font = 'bold 80px "Microsoft YaHei", sans-serif'; // ä¸­æ–‡æ”¯æŒ
    txtCtx.fillStyle = '#fff';
    txtCtx.textAlign = 'center';
    txtCtx.textBaseline = 'middle';
        txtCtx.fillText('æˆ‘æ˜¯å¸…å“¥', txtCanvas.width/2, txtCanvas.height/2);
    
    const imageData = txtCtx.getImageData(0, 0, txtCanvas.width, txtCanvas.height);
    const pixels = [];
    for (let y = 0; y < txtCanvas.height; y += 2) { // é‡‡æ ·æ­¥é•¿
        for (let x = 0; x < txtCanvas.width; x += 2) {
            const index = (y * txtCanvas.width + x) * 4;
            if (imageData.data[index] > 128) {
                pixels.push({
                    x: (x - txtCanvas.width/2) * 0.1, 
                    y: -(y - txtCanvas.height/2) * 0.1 
                });
            }
        }
    }
    // æ˜ å°„åˆ°ç²’å­
    for (let i = 0; i < count; i++) {
        const p = pixels[i % pixels.length];
        textData.push(p.x, p.y, 0);
    }
    shapes.text = textData;

    // 3. Torus (Ring)
    const ringData = [];
    for (let i = 0; i < count; i++) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        const tubeRadius = 2;
        const ringRadius = 8;
        // ç¯é¢å‚æ•°æ–¹ç¨‹
        const x = (ringRadius + tubeRadius * Math.cos(v)) * Math.cos(u);
        const y = (ringRadius + tubeRadius * Math.cos(v)) * Math.sin(u);
        const z = tubeRadius * Math.sin(v);
        ringData.push(x, y, z);
    }
    shapes.ring = ringData;

    // 4. Star
    const starData = [];
    for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2 * 5; // 5åœˆä»¥å¡«æ»¡äº”è§’æ˜Ÿ
        const r = 10 * (Math.abs(Math.cos(angle * 2.5)) * 0.5 + 0.5); // æåæ ‡ç®€æ˜“æ¨¡æ‹Ÿ
        // æ›´å¥½çš„äº”è§’æ˜Ÿé€»è¾‘ï¼šä½¿ç”¨ä¸¤ä¸ªåœ†åŠå¾„äº¤æ›¿
        const k = i % 10 < 5 ? 10 : 4;
        const t = (i / count) * Math.PI * 2;
        // éšæœºå¡«å……äº”è§’æ˜Ÿå†…éƒ¨
        const randR = Math.sqrt(Math.random()) * 12;
        const starAngle = (Math.floor(Math.random() * 5) / 5) * Math.PI * 2;
        // ç®€å•å‚æ•°æ–¹ç¨‹
        const x = randR * Math.cos(t);
        const y = randR * Math.sin(t); 
        // å®é™…ç”¨ä¸€ä¸ªç®€å•çš„å‡ ä½•ä½“é¡¶ç‚¹æˆ–è€…å…¬å¼ä¼šæ›´åƒï¼Œè¿™é‡Œç”¨æ•°å­¦å…¬å¼æ¨¡æ‹Ÿ
        const p = getStarPoint(); 
        starData.push(p.x, p.y, 0);
    }
    function getStarPoint() {
        // æ‹’ç»åˆ†å¸ƒ
        while(true) {
            const x = (Math.random() - 0.5) * 25;
            const y = (Math.random() - 0.5) * 25;
            // ç®€å•çš„æ˜Ÿå½¢ SDF åˆ¤æ–­
            const l = Math.sqrt(x*x+y*y);
            const a = Math.atan2(y,x) + Math.PI/2;
            const r = 8 * (0.6 + 0.4 * Math.cos(5 * a)); 
            if (l < r) return {x, y};
        }
    }
    shapes.star = starData;

    // 5. Heart
    const heartData = [];
    for (let i = 0; i < count; i++) {
        // å¿ƒå½¢çº¿ r = 1-sin(theta) æˆ–è€…å‚æ•°æ–¹ç¨‹
        const t = Math.random() * Math.PI * 2;
        // æ›´é¥±æ»¡çš„å¿ƒå½¢å…¬å¼
        // x = 16sin^3(t)
        // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
        // åŠ ä¸Šå†…éƒ¨å¡«å……
        const scale = 0.5 * Math.sqrt(Math.random()); 
        const xx = 16 * Math.pow(Math.sin(t), 3);
        const yy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        heartData.push(xx * scale, yy * scale, 0);
    }
    shapes.heart = heartData;

    // é»˜è®¤ç›®æ ‡
    updateTargets('sphere');
}

function updateTargets(shapeKey) {
    const data = shapes[shapeKey];
    for (let i = 0; i < CONFIG.particleCount * 3; i++) {
        targets[i] = data[i];
    }
    
    // çˆ†ç‚¸ç‰¹æ•ˆï¼šç»™æ‰€æœ‰ç²’å­ä¸€ä¸ªéšæœºé€Ÿåº¦
    if (shapeKey !== currentShape) {
        explode();
    }
    currentShape = shapeKey;
    document.getElementById('status-text').innerText = `å½“å‰æ¨¡å¼: ${shapeKey.toUpperCase()}`;
}

function explode() {
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const idx = i * 3;
        velocities[idx] += (Math.random() - 0.5) * CONFIG.explosionForce * 2;
        velocities[idx+1] += (Math.random() - 0.5) * CONFIG.explosionForce * 2;
        velocities[idx+2] += (Math.random() - 0.5) * CONFIG.explosionForce * 2;
    }
}

/**
 * 4. ç‰©ç†å¼•æ“ä¸»å¾ªç¯
 */
function updateParticles() {
    const positionsAttr = geometry.attributes.position;
    const count = CONFIG.particleCount;
    
    // æ‰‹éƒ¨é£æš´é€»è¾‘ï¼šè®¡ç®—æ‰‹éƒ¨é€Ÿåº¦å¤§å°
    const speed = handVelocity.length();
    const isStorm = speed > 0.05; // é€Ÿåº¦é˜ˆå€¼

    // æ˜ å°„æ‰‹éƒ¨ä½ç½®åˆ° 3D ç©ºé—´ (ç®€åŒ–æ˜ å°„ï¼Œå‡è®¾z=0å¹³é¢)
    const handX = (handCentroid.x - 0.5) * 40 * -1; // é•œåƒ
    const handY = (handCentroid.y - 0.5) * -30;
    const handZ = 0;

    for (let i = 0; i < count; i++) {
        const idx = i * 3;

        // 1. å¸å¼•åŠ› (Spring Force): Hooke's Law
        // F = -k * x
        const ax = (targets[idx] - positions[idx]) * CONFIG.stiffness;
        const ay = (targets[idx+1] - positions[idx+1]) * CONFIG.stiffness;
        const az = (targets[idx+2] - positions[idx+2]) * CONFIG.stiffness;

        velocities[idx] += ax;
        velocities[idx+1] += ay;
        velocities[idx+2] += az;

        // 2. äº¤äº’åŠ› (Repulsion/Wind)
        if (isHandPresent) {
            const dx = positions[idx] - handX;
            const dy = positions[idx+1] - handY;
            const dz = positions[idx+2] - handZ;
            const distSq = dx*dx + dy*dy + dz*dz;

            // é£æš´æ¨¡å¼ï¼šèŒƒå›´å¤§ï¼ŒåŠ›åº¦å¤§
            if (isStorm && distSq < 150) {
                const force = CONFIG.windForce / Math.sqrt(distSq + 0.1);
                velocities[idx] += dx * force * speed * 2;
                velocities[idx+1] += dy * force * speed * 2;
                velocities[idx+2] += dz * force * speed * 2;
            }
            // æ™®é€šæ–¥åŠ›ï¼šé˜²æ­¢ç²’å­ç©¿è¿‡æ‰‹
            else if (distSq < 20) {
                const force = 0.5 / Math.sqrt(distSq + 0.1);
                velocities[idx] += dx * force;
                velocities[idx+1] += dy * force;
                velocities[idx+2] += dz * force;
            }
        }

        // 3. é˜»å°¼ (Damping)
        velocities[idx] *= CONFIG.damping;
        velocities[idx+1] *= CONFIG.damping;
        velocities[idx+2] *= CONFIG.damping;

        // 4. æ›´æ–°ä½ç½® (Verlet integration simplified)
        positions[idx] += velocities[idx];
        positions[idx+1] += velocities[idx+1];
        positions[idx+2] += velocities[idx+2];
    }

    positionsAttr.needsUpdate = true;
    
    // 5. æ·±åº¦äº¤äº’ (ç›¸æœº Zoom)
    // æ ¹æ®æ‰‹æŒå æ¯”å¹³æ»‘ç§»åŠ¨ç›¸æœº
    if (isHandPresent && palmRatio > 0) {
        // palmRatio é€šå¸¸åœ¨ 0.05 (è¿œ) åˆ° 0.3 (è¿‘) ä¹‹é—´
        // ç›®æ ‡ Z: è¿œåˆ™ 40ï¼Œè¿‘åˆ™ 15
        const targetZ = 45 - (palmRatio * 100); 
        camera.position.z += (targetZ - camera.position.z) * 0.1; // å¹³æ»‘ Lerp
    } else {
        camera.position.z += (30 - camera.position.z) * 0.05; // å¤ä½
    }
}

function render() {
    updateParticles();
    
    // åœºæ™¯å¾®æ—‹è½¬
    scene.rotation.y += 0.001;
    scene.rotation.x = Math.sin(Date.now() * 0.0005) * 0.1;

    renderer.render(scene, camera);
    animationFrameId = requestAnimationFrame(render);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * 5. MediaPipe Hands é€»è¾‘
 */
const videoElement = document.getElementById('video-input');
const hands = new Hands({locateFile: (file) => {
    return `https://unpkg.com/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(onHandsResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

// æ‰‹åŠ¿è¯†åˆ«ç®€æ˜“é€»è¾‘
function detectGesture(landmarks) {
    // å…³é”®ç‚¹ç´¢å¼•
    // 0: æ‰‹è…•, 4: æ‹‡æŒ‡å°–, 8: é£ŸæŒ‡å°–, 12: ä¸­æŒ‡å°–, 16: æ— åæŒ‡å°–, 20: å°æŒ‡å°–
    
    // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (æŒ‡å°–y < æŒ‡å…³èŠ‚yï¼Œæ³¨æ„åæ ‡ç³»yå‘ä¸‹ä¸ºæ­£)
    // å®é™…ä¸Šç”¨å‘é‡ç‚¹ç§¯æ›´å‡†ï¼Œè¿™é‡Œç”¨ç®€å•çš„ç›¸å¯¹é«˜åº¦ï¼Œåœ¨æ‰‹æŒæ­£å¯¹æ‘„åƒå¤´æ—¶æœ‰æ•ˆ
    
    const wrist = landmarks[0];
    
    const isFingerUp = (tipIdx, pipIdx) => {
        // è®¡ç®—è·ç¦» wrist çš„è·ç¦»ï¼Œå¦‚æœ tip è·ç¦»æ¯” pip è¿œï¼Œä¸”æ–¹å‘ä¸€è‡´
        const dTip = Math.hypot(landmarks[tipIdx].x - wrist.x, landmarks[tipIdx].y - wrist.y);
        const dPip = Math.hypot(landmarks[pipIdx].x - wrist.x, landmarks[pipIdx].y - wrist.y);
        return dTip > dPip * 1.2; // ç®€å•çš„å»¶ä¼¸åˆ¤æ–­
    };

    const thumbUp = isFingerUp(4, 2);
    const indexUp = isFingerUp(8, 6);
    const middleUp = isFingerUp(12, 10);
    const ringUp = isFingerUp(16, 14);
    const pinkyUp = isFingerUp(20, 18);
    
    let gesture = '';

    // é€»è¾‘åˆ¤å®šæ ‘
    if (thumbUp && indexUp && middleUp && ringUp && pinkyUp) {
        gesture = 'sphere'; // äº”æŒ‡å¼ å¼€ -> Open
    } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
        gesture = 'text'; // å‰ªåˆ€æ‰‹ -> Victory
    } else if (!indexUp && !middleUp && !ringUp && !pinkyUp && !thumbUp) {
        gesture = 'ring'; // æ¡æ‹³ -> Fist
    } else if (indexUp && !middleUp && !ringUp && !pinkyUp) {
        gesture = 'star'; // é£ŸæŒ‡ -> Point
    } else if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) {
        gesture = 'heart'; // æ‹‡æŒ‡ -> Thumb
    }

    return gesture;
}

function onHandsResults(results) {
    document.getElementById('loading').style.display = 'none';
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        isHandPresent = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. æ›´æ–°æ‰‹æŒä¸­å¿ƒ (å– 0, 5, 17 çš„å¹³å‡å€¼ä½œä¸ºæŒå¿ƒ)
        const cx = (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3;
        const cy = (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3;
        
        // è®¡ç®—æ‰‹éƒ¨é€Ÿåº¦ (ç®€å•çš„å·®åˆ†)
        const currHandPos = new THREE.Vector2(cx, cy);
        handVelocity.subVectors(currHandPos, prevHandPos);
        prevHandPos.copy(currHandPos);
        
        handCentroid.set(cx, cy, 0);

        // 2. è®¡ç®—æ‰‹æŒå¤§å° (ç”¨äºæ·±åº¦) - å–æ‰‹è…•åˆ°ä¸­æŒ‡æ ¹éƒ¨çš„è·ç¦»
        const palmSize = Math.hypot(landmarks[0].x - landmarks[9].x, landmarks[0].y - landmarks[9].y);
        palmRatio = palmSize; // 0 ~ 1 ä¹‹é—´

        // 3. æ‰‹åŠ¿è¯†åˆ«
        const gesture = detectGesture(landmarks);
        if (gesture && gesture !== currentShape) {
            updateTargets(gesture);
        }

    } else {
        isHandPresent = false;
        handVelocity.set(0, 0);
        palmRatio = 0;
    }
}

// å¯åŠ¨
initThree();
cameraUtils.start();
render();

</script>
</body>
</html>
